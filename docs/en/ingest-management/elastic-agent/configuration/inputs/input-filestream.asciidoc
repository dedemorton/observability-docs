:input-type: filestream

[[filestream-input]]
= Filestream input

++++
<titleabbrev>Filestream</titleabbrev>
++++

Use the `filestream` input to read lines from active log files. 

To configure this input, specify a list of glob-based `paths` that must be
crawled to locate and fetch the log lines.

Example configuration:

[source,yaml]
----
inputs:
- type: filestream
  id: my-filestream-id
  paths:
    - /var/log/messages
    - /var/log/*.log
----


You can apply additional settings (such as `fields`, `include_lines`,
`exclude_lines`, `multiline`, and so on) to the lines harvested from these
files. The settings are applied to all files harvested by this input.

{also-see-common-input-settings}

To apply different configuration settings to different files, you need to define
multiple input sections:

[source,yaml]
----
inputs:
  - type: filestream <1>
    streams:
      - paths:
        - /var/log/system.log
        - /var/log/wifi.log
  - type: filestream <2>
    streams:
      - paths:
        - "/var/log/apache2/*"
        fields:
          apache: true
----
<1> Harvests lines from two files:  `system.log` and `wifi.log`.
<2> Harvests lines from every file in the `apache2` directory, and uses the
`fields` configuration setting to add a field called `apache` to the output.

[[input-filestream-file-identity]]
== Reading files on network shares and cloud providers

WARNING: {agent} does not support reading from network shares and cloud
providers.

You can mitigate this limitation somewhat by changing some default settings.

By default, {agent} identifies files based on their inodes and
device IDs. However, on network shares and cloud providers, these
values might change during the lifetime of the file. If this happens
{agent} reads the file as new and resends the whole file. To solve this problem,
configure the `file_identity` setting. The valid values are `inode_deviceid`
(default), `path`, and `inode_marker`.

WARNING: Changing `file_identity` methods between runs may result in
duplicated events in the output.

* Set `path` to identify files based on their paths. This is a quick way to
avoid rereading files if inode and device IDs might change. However, keep in
mind if the files are rotated (renamed), they will be reread and resubmitted.

* Set `inode_marker` if the inodes stay the same even if the device ID is changed.
If your files are rotated, use `inode_marker` instead of `path`, if possible.
You must also configure a marker file readable by {agent} and set the path under
`inode_marker`.

The content of the marker file must be unique to the device. You can put the
UUID of the device or mountpoint where the input is stored. The following
example generates a hidden marker file for the selected mountpoint `/logs`:

NOTE: Do not use this setting on Windows where file identifiers are more
volatile.

[source,shell]
----
$ lsblk -o MOUNTPOINT,UUID | grep /logs | awk '{print $2}' >> /logs/.agent-marker
----

To set the generated file as a marker for `file_identity`, configure
the input as follows:

[source,yaml]
----
inputs:
  - type: filestream
    paths:
      - /logs/*.log
    file_identity.inode_marker:
      path: /logs/.agent-marker
----


[[input-filestream-rotating-logs]]
== Reading from rotating logs

When dealing with file rotation, avoid harvesting symlinks. Instead
use the `paths` setting to point to the original file, and specify
a pattern that matches the file and all of its rotated files. Also make sure
your log rotation strategy prevents lost or duplicate messages.

//For more information, see <<file-log-rotation>>.

To avoid duplicates of rotated log messages, do not use the `path` method for
`file_identity`. Or exclude the rotated files by using the `exclude_files`
setting.

[[input-filestream-prospector-scanner-settings]]
include::input-shared-prospector-scanner.asciidoc[leveloffset=+1]

include::input-filestream-reader-options.asciidoc[leveloffset=+1]


